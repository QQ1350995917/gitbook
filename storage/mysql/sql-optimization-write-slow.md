# C-N-V-D测试数据MySQL插入慢

[先查看执行过程](optimization-02.md)

## 调整数据库参数
### innodb_flush_log_at_trx_commit
默认为1，这是数据库的事务提交设置参数，可选值如下：

0: 日志缓冲每秒一次地被写到日志文件，并且对日志文件做到磁盘操作的刷新，但是在一个事务提交不做任何操作。

1：在每个事务提交时，日志缓冲被写到日志文件，对日志文件做到磁盘操作的刷新。

2：在每个提交，日志缓冲被写到文件，但不对日志文件做到磁盘操作的刷新。对日志文件每秒刷新一次。

有人会说如果改为不是1的值会不会不安全呢？ 安全性比较如下：

在 mysql 的手册中，为了确保事务的持久性和一致性，都是建议将这个参数设置为 1 。出厂默认值是 1，也是最安全的设置。

当innodb_flush_log_at_trx_commit和sync_binlog 都为 1 时是最安全的，在mysqld 服务崩溃或者服务器主机crash的情况下，binary log 只有可能丢失最多一个语句 或者一个事务。

但是这种情况下，会导致频繁的io操作，因此该模式也是最慢的一种方式。

- 当innodb_flush_log_at_trx_commit设置为0，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。
- 当innodb_flush_log_at_trx_commit设置为2，只有在操作系统崩溃或者系统掉电的情况下，上一秒钟所有事务数据才可能丢失。

针对同一个表通过c#代码按照系统业务流程进行批量插入，性能比较如下所示：

- （a.相同条件下：innodb_flush_log_at_trx_commit=0，插入50W行数据所花时间25.08秒;
- （b.相同条件下：innodb_flush_log_at_trx_commit=1，插入50W行数据所花时间17分21.91秒;
- （c.相同条件下：innodb_flush_log_at_trx_commit=2，插入50W行数据所花时间1分0.35秒。

结论：设置为0的情况下，数据写入是最快的，能迅速提升数据库的写入性能， 但有可能丢失上1秒的数据。

### temp_table_size,heap_table_size

这两个参数主要影响临时表temporary table 以及内存数据库引擎memory engine表的写入，设置太小，甚至会出现table is full的报错信息.

要根据实际业务情况设置大于需要写入的数据量占用空间大小才行。

### max_allowed_packet=256M,net_buffer_length=16M，set autocommit=0

备份和恢复时如果设置好这三个参数,可以让你的备份恢复速度飞起来哦！

### innodb_data_file_path=ibdata1:1G;ibdata2:64M:autoextend

很显然表空间后面的autoextend就是让表空间自动扩展，不够默认情况下只有10M，而在大批量数据写入的场景，不妨把这个参数调大；

让表空间增长时一次尽可能分配更多的表空间，避免在大批量写入时频繁的进行文件扩容

### innodb_log_file_size,innodb_log_files_in_group,innodb_log_buffer_size

设置事务日志的大小，日志组数，以及日志缓存。默认值很小，innodb_log_file_size默认值才几十M，innodb_log_files_in_group默认为2。

然而在innodb中，数据通常都是先写缓存，再写事务日志，再写入数据文件。设置太小，在大批量数据写入的场景，必然会导致频繁的触发数据库的检查点，去把 日志中的数据写入磁盘数据文件。频繁的刷新buffer以及切换日志，就会导致大批量写入数据性能的降低。

当然，也不宜设置过大。过大会导致数据库异常宕机时，数据库重启时会去读取日志中未写入数据文件的脏数据，进行redo，恢复数据库，太大就会导致恢复的时间变的更长。当恢复时间远远超出用户的预期接受的恢复时间，必然会引起用户的抱怨。

这方面的设置倒可以参考华为云的数据库默认设置,在华为云2核4G的环境，貌似默认配置的buffer:16M,log_file_size:1G----差不多按照mysql官方建议达到总内存的25%了；而日志组files_in_group则设置为4组。

![](images/sql-optimization-write-01.jpg)
2核4G这么低的硬件配置，由于参数设置的合理性，已经能抗住每秒数千次，每分钟8万多次的读写请求了。

而假如在写入数据量远大于读的场景，或者说方便随便改动参数的场景，可以针对大批量的数据导入，再做调整，把log_file_size调整的更大，可以达到innodb_buffer_pool_size的25%~100%。

### innodb_buffer_pool_size

设置MySQL Innodb的可用缓存大小。理论上最大可以设置为服务器总内存的80%.

设置越大的值，当然比设置小的值的写入性能更好。比如上面的参数innodb_log_file_size就是参考innodb_buffer_pool_size的大小来设置的。
 
### innodb_thread_concurrency=16

故名思意，控制并发线程数，理论上线程数越多当然会写入越快。当然也不能设置过大官方建议是CPU核数的两倍左右最合适。

### write_buffer_size
控制单个会话单次写入的缓存大小，默认值4K左右，一般可以不用调整。然而在频繁大批量写入场景，可以尝试调整为2M，你会发现写入速度会有一定的提升。

### innodb_buffer_pool_instance

默认为1，主要设置内存缓冲池的个数，简单一点来说，是控制并发读写innodb_buffer_pool的个数。

在大批量写入的场景，同样可以调大该参数，也会带来显著的性能提升。

### bin_log

二进制日志，通常会记录数据库的所有增删改操作。然而在大量导数据，比如数据库还原的时候不妨临时关闭bin_log,关掉对二进制日志的写入，让数据只写入数据文件，迅速完成数据恢复，完了再开启吧。

## 减少磁盘IO，提高磁盘读写效率

### 硬件优化

- 在资源有限的情况下，安装部署的时候，操作系统中应有多个磁盘，把应用程序，数据库文件，日志文件等分散到不同的磁盘存储，减轻每个磁盘的IO，从而提升单个磁盘的写入性能。
- 采用固态硬盘SSD,如果资源足够可以采用SSD存储，SSD具有高速写入的特性，同样也能显著提升所有的磁盘IO操作。

### 数据库系统架构优化
- 做主从复制；
  
  比如部署一个双主从，双主从模式部署是为了相互备份，能保证数据安全，不同的业务系统连接不同的数据库服务器，结合ngnix或者keepalive自动切换的功能实现负载均衡以及故障时自动切换。

  通过这种架构优化，分散业务系统的并发读写IO从一台服务器到多台服务器，同样能提高单台数据库的写入速度。

- 做读写分离
  
  和1中要考虑的问题一样，可以减轻单台服务器的磁盘IO，还可以把在服务器上的备份操作移到备服务器，减轻主服务器的IO压力，从而提升写入性能。
  
## 其他影响插入性能的因素
   
   
   
### 1、首先是插入的时候，要注意缓冲区的大小使用情况
    
在分析源码的过程中，有一句话：如果buffer pool余量不足25%，插入失败，返回DB_LOCK_TABLE_FULL。这个错误并不是直接报错：max_allowed_packet 不够大之类的，这个错误是因为对于innodb引擎来说，一次插入是涉及到事务和锁的，在插入索引的时候，要判断缓冲区的剩余情况，所以插入并不能仅仅只考虑max_allowed_packet的问题，也要考虑到缓冲区的大小。

参考淘宝的数据库日报：http://mysql.taobao.org/monthly/2017/09/10/

### 2、插入缓存

另外对于innodb引擎来说，因为存在插入缓存（Insert Buffer）这个概念，所以在插入的时候也是要耗费一定的缓冲池内存的。当写密集的情况下，插入缓冲会占用过多的缓冲池内存，默认最大可以占用到1/2的缓冲池内存，当插入缓冲占用太多缓冲池内存的情况下，会影响到其他的操作。

也就是说，插入缓冲受到缓冲池大小的影响，缓冲池大小为：

```text

mysql> show variables like 'innodb_buffer_pool_size';
+-------------------------+-----------+
| Variable_name           | Value     |
+-------------------------+-----------+
| innodb_buffer_pool_size | 134217728 |
+-------------------------+-----------+
```

换算后的结果为：128M，也就是说，插入缓存最多可以占用64M的缓冲区大小。这个大小要超过咱们设置的sql语句大小，所以可以忽略不计。

我们都知道，在InnoDB引擎上进行插入操作时，一般需要按照主键顺序进行插入，这样才能获得较高的插入性能。当一张表中存在非聚簇的且不唯一的索引时，在插入时，数据页的存放还是按照主键进行顺序存放，

但是对于非聚簇索引叶节点的插入不再是顺序的了，这时就需要离散的访问非聚簇索引页，由于随机读取的存在导致插入操作性能下降。

InnoDB为此设计了Insert Buffer来进行插入优化。对于非聚簇索引的插入或者更新操作，不是每一次都直接插入到索引页中，而是先判断插入的非聚集索引是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer中。看似数据库这个非聚集的索引已经查到叶节点，而实际没有，这时存放在另外一个位置。然后再以一定的频率和情况进行Insert Buffer和非聚簇索引页子节点的合并操作。这时通常能够将多个插入合并到一个操作中，这样就大大提高了对于非聚簇索引的插入性能。

### 3、使用事务提升效率

还有一种说法，使用事务可以提高数据的插入效率，这是因为进行一个INSERT操作时，MySQL内部会建立一个事务，在事务内才进行真正插入处理操作。通过使用事务可以减少创建事务的消耗，所有插入都在执行后才进行提交操作。大概如下：

```text
START TRANSACTION;
INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
    VALUES ('0', 'userid_0', 'content_0', 0);
INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) 
    VALUES ('1', 'userid_1', 'content_1', 1);
...
COMMIT;
```

事务需要控制大小，事务太大可能会影响执行的效率。MySQL有innodb_log_buffer_size配置项，超过这个值会把innodb的数据刷到磁盘中，这时，效率会有所下降。所以比较好的做法是，在数据达到这个这个值前进行事务提交。

```text
show variables like '%innodb_log_buffer_size%';
+------------------------+----------+
| Variable_name          | Value    |
+------------------------+----------+
| innodb_log_buffer_size | 67108864 |
+------------------------+----------+
```

大概是：64M

这种写法和批量写入的效果差不多，只不过sql语句还是单句的，然后统一提交。一个瓶颈是SQL语句的大小，一个瓶颈是事务的大小。当我们在提交sql的时候，首先是受到sql大小的限制，其次是受到事务大小的限制。在开启事务的情况下使用批量插入，会节省不少事务的开销，如果要追求极致的速度的话，建议是开着事务插入的。不过需要注意一下，内存是有限且共享的，如果批量插入占用太多的事务内存，那么势必会对其他的业务操作等有一定的影响。

### 4、通过配置提升读写性能

也可以通过增大innodb_buffer_pool_size 缓冲区来提升读写性能，只是缓冲区是要占用内存空间的，内存很珍贵，所以这个方案在内存富裕，而性能瓶颈的时候，可以考虑下。

#### 5、索引影响插入性能

如果表中存在多个字段索引，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护。这样就降低了数据的插入速度。对于普通的数据表，主键索引是肯定要有的，想要加快性能的话，就是要有序插入，每次插入记录都在索引的最后面，索引的定位效率很高，并且对索引调整较小。如果插入的记录在索引中间，需要B+tree进行分裂合并等处理，会消耗比较多计算资源，并且插入记录的索引定位效率会下降，数据量较大时会有频繁的磁盘操作。   
   
     
## [官方手册](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html)
     
## [数据库内核月报](http://mysql.taobao.org/monthly/2017/09/10/) 
    
## 参考资料

https://zhuanlan.zhihu.com/p/341686785  
https://www.imooc.com/article/291781
https://cloud.tencent.com/developer/article/1200824
https://my.oschina.net/songhongxu/blog/163063
https://my.oschina.net/anuodog/blog/3002941
