#MQ

同步消息

异步消息

## 异步消息

解耦，削峰，容错，伸缩

异步消息的两种实现方式

## 消息队列

## 发布/订阅

- 1）临时（ephemeral）订阅，这种订阅只有在消费者启动并且运行的时候才存在。一旦消费者退出，相应的订阅以及尚未处理的消息就会丢失。
- 2）持久（durable）订阅，这种订阅会一直存在，除非主动去删除。消费者退出后，消息系统会继续维护该订阅，并且后续消息可以被继续处理。


在许多队列系统中常常用主题（topics）这个术语指代发布/订阅模式。在RabbitMQ中，主题就是发布/订阅模式的一种具体实现（更准确点说是交换器（exchange）的一种）。

Kafka的实现很好地契合发布/订阅模式。


## RabbitMQ & Kafka

### 消息顺序
Kafka是获胜者，因为它可以保证按顺序处理消息。RabbitMQ在这块就相对比较弱。

### 消息路由

在消息路由和过滤方面，RabbitMQ提供了更好的支持。

### 消息时序（timing）

#### 消息存活时间（TTL）

#### 延迟/预定的消息

RabbitMQ是获胜者，因为这种实现天然的就限制Kafka。


### 消息留存（retention）
Kafka设计之初就是保存消息的，但是RabbitMQ并不是。

### 容错处理
消息处理存在两种可能的故障：
- 1）瞬时故障——故障产生是由于临时问题导致，比如网络连接，CPU负载，或者服务崩溃。我们可以通过一遍又一遍的尝试来减轻这种故障。
- 2）持久故障——故障产生是由于永久的问题导致的，并且这种问题不能通过额外的重试来解决。比如常见的原因有软件bug或者无效的消息格式（例如，损坏（poison）的消息）。

作为架构师和开发者，我们应该问问自己：“对于消息处理故障，我们应该重试多少次？每一次重试之间我们应该等多久？我们怎样区分瞬时和持久故障？”

最重要的是：“所有重试都失败后或者遇到一个持久的故障，我们要做什么？”

RabbitMQ是获胜者，因为它提供了一个解决这个问题的开箱即用的机制。

### 伸缩
尽管这两个消息平台都可以处理大规模负载，但是Kafka在伸缩方面更优并且能够获得比RabbitMQ更高的吞吐量，因此这局Kafka获胜。

但是，值得注意的是大部分系统都还没有达到这些极限！所以，除非你正在构建下一个非常受欢迎的百万级用户软件系统，否则你不需要太关心伸缩性问题，毕竟这两个消息平台都可以工作的很好。

### 消费者复杂度
RabbitMQ使用的是智能代理和傻瓜式消费者模式。消费者注册到消费者队列，然后RabbitMQ把传进来的消息推送给消费者。RabbitMQ也有拉取（pull）API；不过，一般很少被使用。

RabbitMQ管理消息的分发以及队列上消息的移除（也可能转移到DLX）。消费者不需要考虑这块。根据RabbitMQ结构的设计，当负载增加的时候，一个队列上的消费者组可以有效的从仅仅一个消费者扩展到多个消费者，并且不需要对系统做任何的改变。

根据设计，RabbitMQ就是为了傻瓜式消费者而构建的。所以这轮RabbitMQ获胜。


### 如何选择？
优先选择RabbitMQ的条件：
- 高级灵活的路由规则；
- 消息时序控制（控制消息过期或者消息延迟）；
- 高级的容错处理能力，在消费者更有可能处理消息不成功的情景中（瞬时或者持久）；
- 更简单的消费者实现。

优先选择Kafka的条件：
- 严格的消息顺序；延长消息留存时间，包括过去消息重放的可能；
- 传统解决方案无法满足的高伸缩能力。

这些限制如下：

- 当前开发者对这两个消息平台的了解；
- 托管云解决方案的可用性（如果适用）；
- 每种解决方案的运营成本；
- 适用于我们目标栈的SDK的可用性。

## [Redis MQ](../../storage/redis/04-mq.md)

## 参考资料
https://www.zhihu.com/question/275090117/answer/1645290543

https://www.zhihu.com/question/43557507/answer/370979636



