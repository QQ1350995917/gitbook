# IO

* ## 文件描述符fd

lunix系统把任何对象看做是文件，文件就是一串二进制流，对数据\(流\)的读写操作就是对文件的操作，所以当我们的进程在做读写操作时会返回一个记录访问位置的索引值,当我们继续操作该文件时可直接通过这个索引值到达上一次的位置。

文件描述符\(file description\)，用于表述指向文件引用的抽象，文件描述符在形式上是一个非负整数,实际上它是一个索引值,指向内核为每一个进程所维护的该进程打开文件的记录表，当程序打开一个现有文件或者创建一个新文件时，内核就向该进程返回一个文件描述符。

* ## 用户空间和内核空间与进程

现在操作系统都是采用虚拟存储器,对于32位操作系统,它的寻址空间为4G.操作系统的核心是内核,独立于普通程序,可以访问受保护的内存空间,也有访问底层硬件设备的所有权限.为了保证用户进程不能直接操作内核,保证内核安全,操作系统将虚拟空间划分为两部分,一部分称为内核空间,一部分称为用户空间,这两部分空间大小和地址范围分别为1G和3G,内核空间供内核使用,用户空间供用户进程使用。

进程是程序的一次动态执行过程,它经历了从代码加载,执行到执行完毕的一个完整过程,这个过程也是进程本身从产生,发展到最终消亡的过程,多进程操作系统能同时运行多个进程,由于CPU具备分时机制,所以每个进程都能获得自己的时间片,由于CPU执行速度非常快,使得所有程序好像是在同时运行一样。

在操作系统中进程是进行系统资源分配,调度和管理的最小单位,进程在执行过程中拥有独立的内存单元,当操作系统加载程序到内存中,操作系统会为每个进程分配4G的虚拟内存空间.地址从0x00000000到0xFFFFFFFF,其中1G\(3-4\)是内核所使用的内核空间,3G\(0-3\)是进程使用的用户空间。

这里要注意的是系统为每个进程分配4G的虚拟内存空间,实际上这4G的虚拟内存是一个可寻址的地址范围,并不是实际的物理内存,这个可寻址的4G地址范围由内存区域表来管理.每个进程所用到的内存区域会通过页表映射到物理内存,所以每个进程都可以使用同样的虚拟内存地址而不冲突,他们的实际物理地址是不同的。

为了控制进程的执行,内核必须有能力挂起正在CPU上运行的进程,并恢复以前挂起的某个进程的执行.这种行为被称为进程切换,任务切换或上下文切换,尽管每个进程都有自己的地址空间,但所有进程都在同一个CPU寄存器里,因此,在恢复一个进程执行前,内核必须确保每个寄存器中含有挂起进程时所需要的值.进程恢复执行前必须装入寄存器的一组数据,称为硬件上下文\(hardware Context\),硬件上下文包含了进程恢复时所需要的所有信息。一个进程的运行转到另一个进程上,需要做很多交接记录位置的动作。

进程的切换和阻塞

进程的切换是内核执行该进程的时间片到期而主动挂起该进程,切换到另一个进程的动作.但是进程在一个时间片内执行过程中,遇到某些期望的事件未发生那么进程就会放弃处理机成了阻塞,致使进程阻塞的典型事件有：请求I/O，申请缓冲空间等。

缓存IO

缓冲区以及对缓冲区的操作,是所有IO的基础,进程执行IO操作可以简单的描述为缓冲区的数据读与写。  
在数据read传输过程中需要将数据从磁盘中拷贝到内核空间的的缓冲区,然后从内核空间拷贝到进程用户空间,这个过程会经历两个阶段:1,等待数据准备,2,将数据重内核拷贝到用户空间,而且这两个过程是需要时间的,这就造成了阻塞.称为阻塞IO。在这个基础上,为了充分利用CPU资源,发展出了非阻塞IO,IO多路复用,信号驱动IO,异步IO。形成了Linux中五种IO类型。其中前四种都是同步IO。

* ## Linux中的IO基本流程

## ![](/socket/images/io-in-linux.jpg)

* ## 阻塞I/O（blocking I/O）

## ![](/socket/images/io-blocked.jpg)

* ## 非阻塞I/O （nonblocking I/O）

## ![](/socket/images/io-none-blocked.jpg)

* ## I/O复用\(select 和poll\) （I/O multiplexing）
* ## 信号驱动I/O （signal driven I/O ）
* ## 异步I/O （asynchronous I/O）
* ## 同步阻塞IO\(BIO\)

### BIO通讯模型图 ![BIO通讯模型图](images/bio0.jpg) 该模型的通讯过程：

* #### 服务端有独立的accept线程负责监听客户端的链接；
* #### Accept线程接收到客户端的链接后开启新的工作线程进行链接处理；
* #### 新的工作线程处理完毕后并响应给客户端，然后线程销毁；

### 该模型下的问题：

* #### 服务端的工作线程数和客户端的连接数1:1；
* #### 当访问量增大，工作线程膨胀，系统内存飙升；
* #### 线程大量的销毁和重建，系统性能急剧下降；
* #### 最终导致进程僵死或系统宕机；
* ## 伪异步IO\(BIO\)

### BIO通讯模型图 ![BIO通讯模型图](images/bio1.jpg) 该模型的改良之处：

* #### 采用了线程池，不在反复的创建销毁线程；
* #### 一定层度上提升了吞吐量和系统效率；

### BIO的同步和阻塞

#### java.io.InputStream中的read方法以及重载都会block。

```
/**
 * Reads the next byte of data from the input stream. The value byte is
 * returned as an <code>int</code> in the range <code>0</code> to
 * <code>255</code>. If no byte is available because the end of the stream
 * has been reached, the value <code>-1</code> is returned. This method
 * blocks until input data is available, the end of the stream is detected,
 * or an exception is thrown.
 *
 * <p> A subclass must provide an implementation of this method.
 *
 * @return     the next byte of data, or <code>-1</code> if the end of the
 *             stream is reached.
 * @exception  IOException  if an I/O error occurs.
 */
public abstract int read() throws IOException;
```

#### 对于read，除非遇到如下三种情况，其余情况都会阻塞：

* #### 有数据可读
* #### 且可读数据读取完毕
* #### 发生异常

#### 对于write，同样是写入到输出流完毕，或者发生异常之前被阻塞。

#### 这说明当写入一方缓慢将会导致读取的一方将会被阻塞,当读取一方缓慢也会导致写入的阻塞，而网络传输缓慢也是导致双方共同缓慢的原因。在网络抖动时候，TCP中的信令通道将会调整window size，直到为0，此时双方将会处于Keep-Alive状态，发送方不能再向TCP缓冲区写入，写入操作将会无限期阻塞，直到TCPwindow size大于0或者发生异常。 BIO中阻塞的具体含义就是消息（线程）读取或者写入的阻塞，阻塞期间其他消息（线程）将会在队列缓冲区中排队。这个排队指的就是BIO中的同步的具体含义。由于在具体场景中单个消息（线程）操作的阻塞，导致在全局中出现多个消息（线程）同步的现象。

#### BIO模型简单，编程复杂度低，适用于低并发,低负载的应用程序。

## 同步非阻塞IO\(NIO\)

### NIO通讯模型图 !\[NIO通讯模型图\]\(images/xxx.png,'待补充'\)

### NIO关键概念

* Buffer
* Channel
* Selector

## 异步非阻塞IO



